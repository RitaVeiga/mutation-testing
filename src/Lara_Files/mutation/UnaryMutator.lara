import kadabra.KadabraAst;
import kadabra.KadabraNodes;

import lara.mutation.MutationGenerator;
import lara.actions.LaraActions;

import lara.Check;

/**
 *
 * Generates a mutation related with a single unary operator.
 *
 * @class
 */
var UnaryMutator = function(originalUnaryOperator, unaryOperator) {
	
	Check.isString(unaryOperator);
	if(!KadabraAst.getUnaryOperators().has(unaryOperator)) {
		throw "Invalid unary operator '" + unaryOperator + "'. Available operators: " + KadabraAst.getUnaryOperators().values();
	}

	// Support "undefined" string
	originalUnaryOperator = originalUnaryOperator === "undefined" ? undefined : originalUnaryOperator;

	if(originalUnaryOperator !== undefined) {
		Check.isString(originalUnaryOperator);
		if(!KadabraAst.getUnaryOperators().has(originalUnaryOperator)) {
			throw "Invalid unary operator '" + originalUnaryOperator + "'. Available operators: " + KadabraAst.getUnaryOperators().values();
		}		
		
		if(originalUnaryOperator === unaryOperator) {
			throw "Original unary operator and new unary operator must be different";		
		}
	}

	
	var originalOpName = originalUnaryOperator !== undefined ? originalUnaryOperator : "all";
	var name = "BinaryOpMutation_" + originalOpName + "_to_" + unaryOperator;

	// Parent constructor
	MutationGenerator.call(this, name);
	
	this.unaryOperator = unaryOperator;
	this.originalUnaryOperator = originalUnaryOperator;	
};

UnaryMutator.prototype.getType = function(){
	return "UnaryMutator";
}

// Inheritance
UnaryMutator.prototype = Object.create(MutationGenerator.prototype);

UnaryMutator.prototype.getOp = function() {
	return this.unaryOperator;
}

UnaryMutator.prototype.getOriginalOp = function() {
	return this.originalUnaryOperator;
}

/*** IMPLEMENTATION OF INSTANCE METHODS ***/

UnaryMutator.prototype.isMutationPoint = function($jp) {
	// Check if binary expression
	if(!$jp.instanceOf("unaryExpression")) {
		return false;
	}
	

	
	if(this.originalUnaryOperator === undefined) {
		// Check if it not the same operator
		if($jp.operator === this.unaryOperator) {
			return false;
		}	
	} else {
		// Check if it is the target operator
		if($jp.operator != this.originalUnaryOperator) {
			return false;
		}
	}
	
	
	
	// TODO: Check if operator is "compatible". For instance, we cannot replace a boolean operator (e.g., &&) with an arithmetic operator (e.g., +)
	
	return true;

}

UnaryMutator.prototype._mutatePrivate = function($jp) {
	// Create a UnaryExpression node
	var $newOp = KadabraNodes.unaryExpression(this.unaryOperator, $jp.operand.copy());
	//var $newOp = $jp.copy();
	//var $newOp = KadabraNodes.unaryExpression(this.unaryOperator, $jp.operand);

	//var $newOp2 = KadabraNodes.binaryExpression("+", $jp.operand.copy(), $jp.operand.copy());
	//println("New op2: " + $newOp2.code);
	//println("Is newOp2 parent init? " + $newOp.getNode().isParentInitialized());

	// Replace given node
	var replaceAction = LaraActions.replaceJp($jp, $newOp);
	//println("Is newOp parent init? " + $newOp.getNode().isParentInitialized());
	
	//println("Is point parent init? " + replaceAction.getPoint().getNode().isParentInitialized());
	return replaceAction.getPoint();
}
